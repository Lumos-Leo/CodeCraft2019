# CodeCraft2019
  第一次参加比赛，成绩还算能接受，在这里写下一些收获和感想，同时算是记录一下比赛的日子，也算是画上句号。  

# Thoughts
  **离比赛结束也已经过去一周时间了，终于有时间来整理一下比赛期间的思路...其实是要感谢自己的队友的，因为自己用的是python写的代码，但是python的执行效率实在太低，影响调试，所以队友把代码改成了c++, 以后的调试优化都是用c++进行的...其实能进复赛真的觉得是上天的眷顾，当然也离不开队友们的奇思妙想...**  

# Insights
  对于比赛的思路，主要有以下几点：  
  * 分时间片来发车，具体来讲就是在每个发车时间内的车的数量，我们是43辆车每个时间片。  
  * 首先我们对车的车速进行了排序，一种主观臆想是车快的先发，慢车后发，这样堵车的概率会降低，但是实验的结果发现并没有多大用处。  
  * dijkstra算法寻最短路径。网上很多算法实现，这里不赘述。其实这里用floyd算法会不会更好？没有进行过实验...  
  * 权值的设置：第一种设置方法是直接用道路长度作为我们的权值；第二种设置方法是利用道路的长度除以最高限速得到的时间来作为权值,我一直觉得这种方法可能更能反映路的真实情况？但是实验结果差强人意...  
  * ’动态'加权，此处引号的意思是因为我们理解的动态加权是在无判题器的条件下的'动态'加权，具体思路是:设置一个权值系数，在每一次车辆走过一条路之后，使得该路的权值等于原本权值加上权值系数（类似加大惩罚系数），每次加完之后的权值系数加1,在此基础上，设置一个阈值，当超过阈值的时候，令权值系数归零。（实验证明，这种加权方法能够有效缓解死锁情况）  
  * 设置一个超参，来规定当系统运行时间运行到一定时候的时候，清空地图，来降低车辆的拥堵和死锁情况。可能是参数设置不当，没有发现有提升。  
  * 初级动态规划，因为dijkstra算法是针对单节点的最短路算法，所以对每一辆车都会进行寻路，但所有车辆中肯定存在同一起点和终点的情况,所以我们考虑把规划过的路线存储，来降低运算时间，但实验结果也不是太好，可能是丧失了动态权值的优势...  
